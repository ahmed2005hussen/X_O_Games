#include <bits/stdc++.h>
#include <string>
#include <algorithm>
#include <sstream>
#include <locale>
using namespace std;

class Process {
public:
    string IName, SName, stat;
    float PID, MU;

    Process(string I, string S, string st, float P, float m)
            : IName(I), SName(S), stat(st), PID(P), MU(m) {}
};

class TaskManager {
private:
    vector<Process> p;

public:
    int loadProcess() {
        FILE* pipe = popen("tasklist /FO CSV", "r");
        if (!pipe) {
            cerr << "Error running tasklist command" << endl;
            return 0;
        }

        char buffer[512];
        fgets(buffer, sizeof(buffer), pipe);  // Skip header line

        while (fgets(buffer, sizeof(buffer), pipe)) {
            string line(buffer);
            replace(line.begin(), line.end(), '\"', ' '); // Remove quotes
            istringstream iss(line);
            vector<string> columns;

            string column;
            while (getline(iss, column, ',')) {
                columns.push_back(column);
            }

            if (columns.size() < 5) {
                continue;  // Ensure we have enough columns
            }

            string IName = columns[0];
            float PID = 0;
            try {
                PID = stof(columns[1]);
            } catch (const invalid_argument&) {
                continue; // Skip invalid lines
            }

            string SName = columns[2];
            string memoryStr = columns[4];
            memoryStr.erase(remove(memoryStr.begin(), memoryStr.end(), ','), memoryStr.end()); // Remove commas
            memoryStr.erase(remove(memoryStr.begin(), memoryStr.end(), 'K'), memoryStr.end()); // Remove 'K'

            float MU = 0;
            try {
                MU = stof(memoryStr);
            } catch (const invalid_argument&) {
                MU = 0; // Default to 0 if memory parsing fails
            }

            string stat = "Running";  // Default status (no actual status info)

            p.emplace_back(IName, SName, stat, PID, MU);
        }

        pclose(pipe);
        return 1;
    }

    void sortByName() {
        sort(p.begin(), p.end(), [](const Process& a, const Process& b) {
            return a.IName < b.IName;
        });
    }

    void sortByPID() {
        sort(p.begin(), p.end(), [](const Process& a, const Process& b) {
            return a.PID < b.PID;
        });
    }

    void sortByMemory() {
        sort(p.begin(), p.end(), [](const Process& a, const Process& b) {
            return a.MU < b.MU;
        });
    }

    string formatMemoryUsage(float memoryUsage) {
        stringstream ss;
        ss.imbue(locale(""));
        ss << fixed << static_cast<int>(memoryUsage) << " K";
        return ss.str();
    }

    void printProcesses() {
        cout << setw(30) << left << "Image Name"
             << setw(15) << "PID"
             << setw(20) << "Session Name"
             << setw(15) << "Status"
             << setw(20) << "Memory Usage" << endl;
        cout << string(100, '=') << endl;

        for (const auto& process : p) {
            cout << setw(30) << left << process.IName
                 << setw(15) << process.PID
                 << setw(20) << process.SName
                 << setw(15) << process.stat
                 << setw(20) << formatMemoryUsage(process.MU) << endl;
        }
    }
};

void Menu() {
    cout << "\nSelect the operation you want to sort by:\n";
    cout << "1. By Name\n";
    cout << "2. By PID\n";
    cout << "3. By Memory Usage\n";
    cout << "4. Exit\n";
}

int main() {
    TaskManager tm;
    if (!tm.loadProcess()) {
        return -1;
    }

    // Print the task manager processes before sorting
    cout << "Task Manager - Initial Process List:" << endl;
    tm.printProcesses();

    int choice;
    while (true) {
        // Show sorting menu after initial display
        Menu();
        cout << "Please enter your choice: ";
        cin >> choice;

        if (choice == 4) {
            cout << "Exiting..." << endl;
            break;
        }

        // Sort the processes based on user input
        switch (choice) {
            case 1:
                tm.sortByName();
                cout << "\nSorted by Name:" << endl;
                tm.printProcesses();
                break;
            case 2:
                tm.sortByPID();
                cout << "\nSorted by PID:" << endl;
                tm.printProcesses();
                break;
            case 3:
                tm.sortByMemory();
                cout << "\nSorted by Memory Usage:" << endl;
                tm.printProcesses();
                break;
            default:
                cout << "Invalid input. Please try again!" << endl;
                break;
        }
    }

    return 0;
}
